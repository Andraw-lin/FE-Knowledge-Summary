# 你搞懂正则了吗

在我开发多年里，正则一直是我最最难以理解的一样东西。说实在的，每次做一些简单的登录注册时，看到需要做对用户输入的字符进行做校验，这时候我就会很习惯地上网去搜相关正则。毕竟除了日常的表单验证需要常用到正则外，我就觉得没什么其他地方能够使用上正则了。

当然的，到了后来，我就发现我的这个观点是错误的...😅 在常见的搜索功能又或者前后端数据交互过程等都是可以利用正则很简单实现。所以今天我终于有时间总结一下自己是如何学习正则了。还是那句话，多动手，多分享。😄



## 一个字符的匹配

正则对我们而言，最简单的方式就是使用写死方式。好比如下面这个🌰：

```js
var reg = /HelloWord/
console.log(reg.test('helloword')) // false
console.log(reg.test('HelloWord')) // true
```

很简单，就是逐个字符逐个字符地写死在正则里面，就可以很完善满足我们的要求。当然弊端也很明显，那就是每次都得知道匹配的值是什么，然后再一次性地匹配，说白了，就是无法做到动态匹配。

那么**在正则里面，为了能够实现动态匹配一个字符，衍生出一些匹配标准**，具体如下：

| 正则表达式 | 含义                                   |
| ---------- | -------------------------------------- |
| .          | 匹配任意字符，除了换行符               |
| \w         | 匹配 a - z，A - Z，0 - 9，_字符        |
| \W         | 匹配除了a - z，A - Z，0 - 9，_外的字符 |
| \d         | 匹配 0 - 9 字符                        |
| \D         | 匹配除了 0 - 9 外的字符                |
| \s         | 匹配空白字符                           |
| \S         | 匹配除了空白字符外的字符               |

**上述表格中的正则匹配，都是为了匹配一个字符用到的**。（这里一定要记住，是匹配一个字符用的！）但是，它们都是为了匹配一个正常字符用的。

那么问题来了，**如果我想只匹配 1，2 两个数字中的任意一个，如何写？其实在正则里允许我们在`[]`符号里编写一些可能出现的字符集合，用于匹配一个字符使用**。所以使用上可以这样，**`[1-2a-c]`用来匹配一个字符是1或者2，又或者是a到c之间某个字符**。

那么**如果一个字符是特殊字符时，又该如何处理**呢？答案就是转义字符。那究竟如何转义呢？

例如，我们**想匹配一个 \& 字符，那就得使用`\&`正则来匹配**。说白了，就是**符号`\`加上相应的特殊字符就能匹配一个特殊字符了**。

当然，开发中会有一些换行符、换页符等特殊字符，正则对于这批特殊字符也给出一个标准，如下。

| 正则表达式 | 含义                     |
| ---------- | ------------------------ |
| \n         | 换行符                   |
| \f         | 换页符（也叫 form feed） |
| \t         | 制表符（也叫 table）     |
| \r         | 回车符（也叫 return）    |
| \s         | 空白符（也叫 space）     |

**除了上述表格中列出的匹配特殊字符外，其他一律采用符号`\`加上相应的特殊字符来匹配一个特殊字符**。



## 一个字符出现次数的范围匹配

既然知道如何对一个字符进行相应的匹配后，接着要是想重复一个字符又是如何操作？又或者说，无法知道该字符出现的次数时又该如何匹配？

针对这个问题，正则的标准也给出了一个相应的规定，如下：

| 正则表达式 | 含义           |
| ---------- | -------------- |
| ?          | 出现0次或者1次 |
| *          | 出现>=0次      |
| +          | 出现>=1次      |

需要注意的是，**上面的三个正则表达式，都是为了它前面的一个字符服务的**！那么我们先看一个🌰：

```js
var reg = /Hel+oWord/
console.log(reg.test('HelloWord')) // true
console.log(reg.test('HelllllloWord')) // true
```

当然上面的三个正则表达式肯定是无法满足我们实际情况的，好比如我确定一个字符是会出现至少 3 次时，那该如何处理？

答案就是**使用`{}`包裹相应的次数，就是表示一个字符出现次数的范围匹配**。

| 正则表达式 | 含义                  |
| ---------- | --------------------- |
| {2,}       | 出现至少2次           |
| {,8}       | 出现至多8次           |
| {2, 8}     | 出现次数在 2 - 8 之间 |

理解上不难，无非就是使用一个`{}`符号包裹出现的次数即可。

不过需要注意的是，**如果上面几个表达式前面的字符串使用`()`包裹的话，那就是表示该字符串出现的次数范围匹配！**



## 边界匹配

什么是边界？简单来说，就是用于形容一个字符或者字符串出现的位置。

好比如，现在有这样的一个字符串`The housewife is always in the house.`，我们需要匹配到`house`这个字符。然后我们就会想当然滴想使用`/house/`来匹配，但是它会匹配到两个，分别是`housewife`和`house`。

好了，在解决上述问题时，我们先看看正则对于边界是如何给出标准的。

| 正则表达式 | 含义                 |
| ---------- | -------------------- |
| \b         | 表示单词边界         |
| \B         | 表示非单词边界       |
| ^          | 表示整个字符串的开头 |
| $          | 表示整个字符串的结尾 |

因为我们要是想匹配到`house`和`housewife`，我们可以如何操作。

```js 
var str1 = 'house'
var str2 = 'housewife'
var reg1 = /\bhouse\b/
var reg2 = /\bhouse\B/
console.log(reg1.test(str)) // true
console.log(reg2.test(str)) // true
```

相信你们对于`^`和`$`都不陌生，毕竟在正则中也是很常见的一个符号，就是分别匹配字符串开头和结尾位置。还是先看一个🌰：

```js
var str = 'haha he asdad '
var reg1 = /^he$/
var reg2 = /^.+he.+$/
console.log(reg1.test(str)) // false
console.log(reg2.test(str)) // true
```



## 修饰符匹配

在正则里，主要定义了三种修饰符匹配，主要如下：

| 修饰符 | 含义           |
| ------ | -------------- |
| m      | 匹配多行模式   |
| i      | 匹配忽略大小写 |
| g      | 匹配全局模式   |

修饰符在使用上很简单，只需要在正则最后面贴上即可。可以看个栗子。

```js
var str = 'aabbcc'
console.log(str.replace(/b/g, 'h')) // aahhcc
```



## 分组匹配

**分组匹配模式使用的是`()`符号**，如果单纯滴使用该括号的话，其实和上面的字符匹配是没有任何区别。那么怎么才能体现它的高级高能呢？

简单来说，要是想体现它的有效性，那么就要将一个长的字符串分段处理，而这里面就不得不使用分组匹配。

举个🌰，现在需要匹配一个 IP 地址，由于一个 IP 地址可分为四部分组成，第一部分肯定是 1 - 255 之间，第二、三、四部分都是 0 - 255 之间，那么这时候就得使用分组完成了，如下。

```js
var reg = /^(1\d{0,2}|2[0-5]{0,2})\,(0|1\d{0,2}|2[0-5]{0,2})\,\2\,\2/
```

通过上述的分组后，就可以很容易清楚每一组的正则到底如何编写。

等等，还是有问题，`\2`到底是什么鬼？别急，下面会继续讲到哈。🤔



## 回溯引用匹配

所谓的回溯引用，指的的就是在模式后面想继续引用前面已经匹配到的字符串。那么回溯引用就必须结合相应的分组匹配了。

**在正则里面，我们可以使用`\`加上数字来表示选择第几个表达式**。当然，**`\1`表示的就是第一个`()`包裹的表达式了**。所以上面的`\2`就是直接引用了第二个表达式`(0|1\d{0,2}|2[0-5]{0,2})`。

**回溯引用在替换方法`replace`中十分常用，但是和正则上引用的语法会有些不太一样，它使用的是`$`加数字表示**。先看个🌰。

```js
var str = 'aabbcc'
console.log(str.replace(/(a)b(b)/, '$2b$1')) // abbacc
```

另外的话，**回溯引用也支持使用`(?:regex)`表示无法被表达式引用**，看个🌰。

```js
var str = 'aabbcc'
console.log(str.replace(/(a)b(?:b)/, '$2b$1')) // a$2bacc
```

那么，对于回溯引用，还有两个很重要的功能点没有提及，那就是**向前查找和向后查找**。

**向前查找使用的是`(?=regex)`，而向后查找则是使用`(?<=regex)`**。那么还是回到上面那个`house`和`housewife`的问题，现在我们有一个字符串`house housewife`，那么我就是将`housewife`前面的`house`替换成`yes`，可使用向前查找。

```js
var str = 'house housewife'
var reg = /house(?=wife)/
console.log(str.replace(reg, 'yes')) // house yeswife
```

向前查找和向后查找都可以很有效滴针对两个具有相同的匹配地方分离出来。

另外的话，**向前查找也有负向前查找，使用的是`(?!regex)`，向后查找也有负向后查找，使用的是`(?<!regex)`**。原理上是一样，好比如我仅仅是想把`house`转化为`yes`，而`housewife`原封不动。

```js
var str = 'house housewife'
var reg = /house(?!wife)/
console.log(str.replace(reg, 'yes')) // yes housewife
```



## 总结

正则表达式在理解后，其实并不难，主要就是需要多动手多实践，便会很快知道其中的原理。目前看来，要重点关注的就是重复匹配、分组匹配、边界匹配、回溯引用。只要多运用这些东西，我相信各位还是能很好滴学会使用正则的，希望这篇文章能够给予大家帮助哈。😄

























































