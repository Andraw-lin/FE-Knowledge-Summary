{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{270:function(e,n,t){\"use strict\";t.r(n);var r=t(0),s=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"手写实现那回事\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#手写实现那回事\"}},[e._v(\"#\")]),e._v(\" 手写实现那回事\")]),e._v(\" \"),t(\"p\",[e._v(\"当下不管是在面试过程中还是在日常开发过程中，一些底层的实现变得越来越有效率性，那么当理解如何实现时，能否直接写出一份实现呢？\")]),e._v(\" \"),t(\"p\",[e._v(\"为此，我特意写了一些自己的理解总结，便于后期的回顾或分享。😄\")]),e._v(\" \"),t(\"h2\",{attrs:{id:\"bind-函数实现\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#bind-函数实现\"}},[e._v(\"#\")]),e._v(\" Bind 函数实现\")]),e._v(\" \"),t(\"p\",[e._v(\"实现 Bind 函数的关键点在于两点。\")]),e._v(\" \"),t(\"ol\",[t(\"li\",[t(\"strong\",[e._v(\"箭头函数中的 this 指向函数定义时所在的作用域\")]),e._v(\"。\")]),e._v(\" \"),t(\"li\",[e._v(\"使用 Bind 函数绑定返回的函数，在使用 new 时，this 的指向会指向新创建的对象，而不是原来已绑定的对象。\")])]),e._v(\" \"),t(\"details\",[t(\"summary\",[e._v(\"答案\")]),e._v(\" \"),t(\"pre\",[t(\"code\",[e._v(\"\\n  Function.prototype.myBind = function(obj) {\\n    // 先判断是否为函数\\n    if(typeof this !== 'function') {\\n      throw new Error('This is not function...')\\n    }\\n    const remainArgs = Array.prototype.slice.call(arguments, 1) // 获取剩余参数\\n    const TempFun = function() {} // 构造一个空函数\\n    const self = this // 缓存当前函数\\n    if(self.prototype) { // 保存当前函数的原型\\n      TempFun.prototype = self.prototype\\n    }\\n    const returnFun = function() {\\n      return self.apply(this instanceof TempFun ? this : obj, remainArgs)\\n    }\\n    returnFun.prototype = new TempFun()\\n    return returnFun\\n  }\\n  \")])])]),e._v(\" \"),t(\"h2\",{attrs:{id:\"call-和-apply-函数实现\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#call-和-apply-函数实现\"}},[e._v(\"#\")]),e._v(\" Call 和 Apply 函数实现\")]),e._v(\" \"),t(\"p\",[e._v(\"实现 Call 函数和 Apply 函数，主要体现在两点。\")]),e._v(\" \"),t(\"ol\",[t(\"li\",[e._v(\"将当前函数保存下来，并使用 Symbol 作为属性名保存在相应对象下面。\")]),e._v(\" \"),t(\"li\",[e._v(\"执行刚刚在相应对象下使用 Symbol 保存的函数，并把该结果进行返回。\")])]),e._v(\" \"),t(\"details\",[t(\"summary\",[e._v(\"答案\")]),e._v(\" \"),t(\"pre\",[t(\"code\",[e._v(\"\\n  Function.prototype.myCall = function(obj) {\\n    if(typeof this !== 'function') {\\n      throw new Error('This is not a function...')\\n    }\\n    const selfFun = this // 保存当前函数\\n    const remainArgs = [...arguments].slice(1) // 获取剩余参数\\n    const fn = Symbol('fn') // 避免对象函数名冲突\\n    obj[fn] = selfFun\\n    const result = obj[fn](...remainArgs) // 保存最终的对象调用函数结果\\n    delete obj[fn] // 删除相应的对象函数\\n    return result\\n  }\\n  \")])])]),e._v(\" \"),t(\"h2\",{attrs:{id:\"reduce-函数实现\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reduce-函数实现\"}},[e._v(\"#\")]),e._v(\" Reduce 函数实现\")]),e._v(\" \"),t(\"p\",[e._v(\"实现 Reduce 函数，主要体现在两点。\")]),e._v(\" \"),t(\"ol\",[t(\"li\",[e._v(\"根据参数获取初始值。\")]),e._v(\" \"),t(\"li\",[e._v(\"在遍历数组的过程中，必须要注意[ empty ]情况。\")])]),e._v(\" \"),t(\"details\",[t(\"summary\",[e._v(\"答案\")]),e._v(\" \"),t(\"pre\",[t(\"code\",[e._v(\"\\n  // reduce方法实现\\n  Array.prototype.myReduce = function(callbackFun) {\\n    let returnSum = undefined // 叠加器最终变量\\n    let index = 0 // 数组遍历的索引\\n    const self = this // 获取当前数组\\n    if(arguments.length > 1) {\\n      returnSum = arguments[1]\\n    } else if(arguments.length === 1) {\\n      returnSum = self[index]\\n      index = 1\\n    }\\n    while(index < self.length) {\\n      let hasVal = self.hasOwnProperty(index)\\n      if(hasVal) {\\n        let currentVal = self[index]\\n        returnSum = callbackFun(returnSum, currentVal, index)\\n      }\\n      index++ \\n    }\\n    return returnSum\\n  }\\n  \")])])]),e._v(\" \"),t(\"h2\",{attrs:{id:\"new-实现\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#new-实现\"}},[e._v(\"#\")]),e._v(\" New 实现\")]),e._v(\" \"),t(\"p\",[e._v(\"new 内部机制主要经历以下四个步骤：\")]),e._v(\" \"),t(\"ol\",[t(\"li\",[e._v(\"创建一个新的对象。\")]),e._v(\" \"),t(\"li\",[e._v(\"将构造函数的作用域赋给该对象。\")]),e._v(\" \"),t(\"li\",[e._v(\"执行构造函数中的代码。\")]),e._v(\" \"),t(\"li\",[e._v(\"返回该新的对象。\")])]),e._v(\" \"),t(\"p\",[e._v(\"因此要实现一个 new 方法，那么必须抓住两点。\")]),e._v(\" \"),t(\"ol\",[t(\"li\",[e._v(\"必须将新创建的对象的原型指针指向构造函数的原型对象。\")]),e._v(\" \"),t(\"li\",[e._v(\"执行完构造函数中的代码后，必须判断其返回值是否为对象，若是则 return，若不是则直接返回刚刚新创建的对象。\")])]),e._v(\" \"),t(\"details\",[t(\"summary\",[e._v(\"答案\")]),e._v(\" \"),t(\"pre\",[t(\"code\",[e._v(\"\\n  // new实现\\n  function myNew() {\\n    const obj = new Object() // 创建一个新的对象\\n    const argsFun = Array.prototype.shift.call(arguments) // 获取构造函数\\n    obj.__proto__ = argsFun.prototype // 将新对象的原型指针指向构造函数的原型对象\\n    const remainArgs = Array.prototype.slice.call(arguments, 0) // 获取剩余参数\\n    const result = argsFun.apply(obj, remainArgs) // 执行构造函数中的代码\\n    return typeof result === 'object' && result !== null ? result : obj // 返回新的对象\\n  }\\n  \")])])]),e._v(\" \"),t(\"p\",[e._v(\"需要注意的是，new 是属于关键字，不能被重写，因此只能使用函数来模拟实现 new 的功能。\")]),e._v(\" \"),t(\"p\",[t(\"strong\",[e._v(\"最重要的点，就是要将新建对象的原型指针__proto__指向参数函数的原型对象！！！\")])]),e._v(\" \"),t(\"h2\",{attrs:{id:\"async-await-实现\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#async-await-实现\"}},[e._v(\"#\")]),e._v(\" async/await 实现\")]),e._v(\" \"),t(\"p\",[e._v(\"async/await 是 generator 语法糖，基于 promise 进行编写的。由于 async/await 都是属于关键字，不能被重写，只能通过使用函数来模拟实现。\")]),e._v(\" \"),t(\"p\",[e._v(\"要实现 async/await 函数，必须遵循下列几点要求。\")]),e._v(\" \"),t(\"ol\",[t(\"li\",[e._v(\"async 函数只能面向 generator 生成器函数，并且最终会返回一个函数，函数执行后会返回一个 Promise 实例。\")]),e._v(\" \"),t(\"li\",[e._v(\"执行 generator 生成器函数时，需\"),t(\"strong\",[e._v(\"使用递归形式进行自执行\")]),e._v(\"，直到最后的 done 为 true 为止才返回最终的结果。\")]),e._v(\" \"),t(\"li\",[e._v(\"需要进行异常处理。\")])]),e._v(\" \"),t(\"details\",[t(\"summary\",[e._v(\"答案\")]),e._v(\" \"),t(\"pre\",[t(\"code\",[e._v(\"\\n  // async/await实现\\n  function asyncFun(callbackFun) {\\n    return function() {\\n      const self = this\\n      const args = arguments\\n      return new Promise((resolve, reject) => {\\n        const gen = callbackFun.apply(self, args)\\n        function _next(value) { // 用于遍历迭代器\\n          awaitFun(resolve, reject, gen, _next, _throw, 'next', value)\\n        }\\n        function _throw(err) { // 用于迭代器遍历时抛出异常\\n          awaitFun(resolve, reject, gen, _next, _throw, 'throw', err)\\n        }\\n        _next() // 迭代器自执行\\n      })\\n    }\\n  }\\n  function awaitFun(res, rej, gen, nextFun, throwFun, funKey, args) {\\n    const nextRes = gen[funKey](args)\\n    if (nextRes.done) {\\n      res(nextRes.value)\\n    } else {\\n      Promise.resolve(nextRes.value).then(nextFun, throwFun)\\n    }\\n  }\\n  \")])])]),e._v(\" \"),t(\"h2\",{attrs:{id:\"双向数据绑定的实现\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#双向数据绑定的实现\"}},[e._v(\"#\")]),e._v(\" 双向数据绑定的实现\")]),e._v(\" \"),t(\"p\",[e._v(\"在 JavaScript 为双向数据绑定的实现提供了两个 API，分别对应于 ES5 版本的\"),t(\"code\",[e._v(\"Object.defineProperty\")]),e._v(\"和 ES6 版本\"),t(\"code\",[e._v(\"Proxy\")]),e._v(\"。\")]),e._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[e._v(\"Object.defineProperty版本\")]),e._v(\" \"),t(\"details\",[t(\"summary\",[e._v(\"答案\")]),e._v(\" \"),t(\"pre\",[t(\"code\",[e._v(\"\\n  // Object.defineProperty实现双向数据绑定\\n  const data = {\\n    text: ''\\n  }\\n  const inputEle = document.querySelector('input')\\n  const spanEle = document.querySelector('span')\\n  Object.defineProperty(data, 'text', {\\n    set(val) {\\n      spanEle.text = val\\n    }\\n  })\\n  inputEle.addEventListener('input', function(e) {\\n    data.text = this.value\\n  })\\n  \")])])])]),e._v(\" \"),t(\"li\",[t(\"p\",[e._v(\"Proxy版本\")]),e._v(\" \"),t(\"details\",[t(\"summary\",[e._v(\"答案\")]),e._v(\" \"),t(\"pre\",[t(\"code\",[e._v(\"\\n  // Proxy实现双向数据绑定\\n  const data = {\\n    text: ''\\n  }\\n  const inputEle = document.querySelector('input')\\n  const spanEle = document.querySelector('span')\\n  const handler = {\\n    set(target, key, value) {\\n      target[key] = value\\n      spanEle.text = value\\n      return value\\n    }\\n  }\\n  const proxyObj = new Proxy(data, handler)\\n  inputEle.addEventListener('input', function(e) {\\n    proxyObj.text = this.value\\n  })\\n  \")])])])])]),e._v(\" \"),t(\"h2\",{attrs:{id:\"object-create方法实现\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#object-create方法实现\"}},[e._v(\"#\")]),e._v(\" Object.create方法实现\")]),e._v(\" \"),t(\"p\",[e._v(\"实现 Object.create 方法，主要是利用寄生式继承。\")]),e._v(\" \"),t(\"p\",[e._v(\"简单理解，就是\"),t(\"strong\",[e._v(\"先构建一个空构造函数，接着将参数对象赋给构造函数的原型对象，并将原型对象中 constructor 指回空构造函数，最后返回空构造函数实例\")]),e._v(\"。\")]),e._v(\" \"),t(\"details\",[t(\"summary\",[e._v(\"答案\")]),e._v(\" \"),t(\"pre\",[t(\"code\",[e._v(\"\\n  // Obejct.create方法实现\\n  Object.prototype.myCreate = function(obj) {\\n    function Noop() {}\\n    Noop.prototype = obj\\n    Noop.constructor = Noop\\n    return new Noop()\\n  }\\n  \")])])]),e._v(\" \"),t(\"h2\",{attrs:{id:\"instanceof-实现\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#instanceof-实现\"}},[e._v(\"#\")]),e._v(\" instanceof 实现\")]),e._v(\" \"),t(\"p\",[e._v(\"instanceof 的机制就是判断右边的构造函数的原型对象是否在左边对象的__proto__的原型链上。\")]),e._v(\" \"),t(\"p\",[e._v(\"要实现 instanceof，那么需要注意的是，\"),t(\"strong\",[e._v(\"利用遍历一直寻找左边对象的__proto__，若等于右边构造函数的原型对象，则返回 true，否则直到遍历为 null 为止\")]),e._v(\"。\")]),e._v(\" \"),t(\"details\",[t(\"summary\",[e._v(\"答案\")]),e._v(\" \"),t(\"pre\",[t(\"code\",[e._v(\"\\n  // instanceof实现\\n  function myInstanceof(left, right) {\\n    let leftPro = left.__proto__\\n    let rightPro = right.prototype\\n    while(leftPro) {\\n      if(leftPro === rightPro) return true\\n      leftPro = leftPro.__proto__\\n    }\\n    return false\\n  }\\n  \")])])]),e._v(\" \"),t(\"h2\",{attrs:{id:\"object-getownpropertynames方法实现\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#object-getownpropertynames方法实现\"}},[e._v(\"#\")]),e._v(\" Object.getOwnPropertyNames方法实现\")]),e._v(\" \"),t(\"p\",[e._v(\"Object.getOwnPropertyNames 用于获取一个对象的所有属性名，不包括原型对象上的。\")]),e._v(\" \"),t(\"p\",[e._v(\"那么，要实现 Object.getOwnPropertyNames 方法，可\"),t(\"strong\",[e._v(\"结合使用 in 操作符和 Object.hasOwnProperty 实现\")]),e._v(\"。\")]),e._v(\" \"),t(\"details\",[t(\"summary\",[e._v(\"答案\")]),e._v(\" \"),t(\"pre\",[t(\"code\",[e._v(\"\\n  // Object.getOwnPropertyNams实现\\n  Object.myGetOwnPropertyNames = function(obj) {\\n    if(typeof obj !== 'object') throw new Error('This is not a object...')\\n    const resultArr = []\\n    for(let allKey in obj) {\\n      if(Object.hasOwnProperty.call(obj, allKey)) {\\n        resultArr.push(allKey)\\n      }\\n    }\\n    return resultArr\\n  }\\n  \")])])]),e._v(\" \"),t(\"h2\",{attrs:{id:\"promise-实现\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#promise-实现\"}},[e._v(\"#\")]),e._v(\" Promise 实现\")]),e._v(\" \"),t(\"p\",[e._v(\"Promise 拥有三种状态，分别是pending、fullfilled、rejected。\")]),e._v(\" \"),t(\"p\",[e._v(\"而 Promise 的实现原理就是，\"),t(\"strong\",[e._v(\"通过队列形式控制每个成功回调以及失败回调的处理，内部使用私有变量保存当前处理状态以及处理所得到的值\")]),e._v(\"。接下来一一分析每个方法的实现要点。\")]),e._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[e._v(\"静态resolve方法。\")]),e._v(\" \"),t(\"p\",[e._v(\"返回一个Promise实例，先判断当前状态是否为pending，若不是直接返回。\")]),e._v(\" \"),t(\"p\",[e._v(\"然后判断参数值是否为Promise实例，若是则必须调用then方法等待其调用完毕才能进行下一步。\")]),e._v(\" \"),t(\"p\",[e._v(\"最后需要对成功回调队列和失败回调队列中进行清空处理（即使用shift方法，一一执行其回调函数）。\")]),e._v(\" \"),t(\"p\",[e._v(\"上述操作必须在一个setTimeout中进行。\")])]),e._v(\" \"),t(\"li\",[t(\"p\",[e._v(\"静态reject方法。\")]),e._v(\" \"),t(\"p\",[e._v(\"返回一个Promise实例，先判断当前状态是否为pending，若不是直接返回。\")]),e._v(\" \"),t(\"p\",[e._v(\"无需判断为Promise实例，直接对失败回调队列进行清空处理（即使用shift方法，一一执行其回调函数）。\")]),e._v(\" \"),t(\"p\",[e._v(\"上述操作必须在一个setTimeout中进行。\")])]),e._v(\" \"),t(\"li\",[t(\"p\",[e._v(\"then方法。\")]),e._v(\" \"),t(\"p\",[e._v(\"返回一个Promise实例，先创建两个处理函数（分别为成功处理函数和失败处理函数）。\")]),e._v(\" \"),t(\"p\",[e._v(\"成功处理函数中操作便是判断then方法的第一个参数是否为函数，若是则先执行其函数（其中内部值作为其函数的参数），接着再执行静态resolve方法清空成功回调队列操作。\")]),e._v(\" \"),t(\"p\",[e._v(\"失败处理函数中操作便是判断then方法的第二个参数是否为函数，若是则先执行其函数（其中内部值作为其函数的参数），接着再执行静态reject方法清空失败回调队列操作。\")]),e._v(\" \"),t(\"p\",[e._v(\"根据状态判断，当内部状态为pending时，则成功回调队列push进成功处理函数，失败回调队列push进失败处理函数，当内部状态为fullfilled时，则直接执行成功处理函数（其中内部值作为其函数的参数），当内部状态为rejected时，则直接执行失败回调处理函数（其中内部值作为其函数的参数）。\")])]),e._v(\" \"),t(\"li\",[t(\"p\",[e._v(\"catch方法。\")]),e._v(\" \"),t(\"p\",[e._v(\"相当于直接执行this.then(undefined, rejectedFun)。\")])]),e._v(\" \"),t(\"li\",[t(\"p\",[e._v(\"finally方法。\")]),e._v(\" \"),t(\"p\",[e._v(\"相当于直接执行this.then(val => MyPromise.resolve(callback()).then(() => val), val => MyPromise.reoslve(callback).then(() => { throw val }))\")])]),e._v(\" \"),t(\"li\",[t(\"p\",[e._v(\"静态all方法。\")]),e._v(\" \"),t(\"p\",[e._v(\"返回一个Promise实例，创建一个空数组，遍历参数Promise数组，执行每一个Promise的then方法，然后将处理好的值push进空数组中，当判断数组长度与参数Promise数组长度一致时即可使用reoslve将处理好的数组返回。\")])]),e._v(\" \"),t(\"li\",[t(\"p\",[e._v(\"静态race方法。\")]),e._v(\" \"),t(\"p\",[e._v(\"返回一个Promise实例，遍历参数Promise数组，执行每一个Promise的then方法，一旦有值返回即可直接resolve返回。\")])])]),e._v(\" \"),t(\"details\",[t(\"summary\",[e._v(\"答案\")]),e._v(\" \"),t(\"pre\",[t(\"code\",[e._v(\"\\n  // Promise类实现\\n  class MyPromise {\\n    constructor(handleFun) {\\n      handleFun(this._resolve, this._reject)\\n      this._status = 'pending' // 当前的promise状态\\n      this._value = undefined  // 当前promise处理的值\\n      this._fullFilledQuene = [] // 当前promise接受处理队列\\n      this._rejectedQuene = [] // 当前promise拒绝处理队列\\n    }\\n    _resolve(val) {\\n      setTimeout(function() {\\n        if(this._status !== 'pending') return\\n        this._status = 'fullfilled'\\n        const runFullfilledQuene = (res) => {\\n          let callback\\n          while(callback = this._fullFilledQuene.shift()) {\\n            callback(res)\\n          }\\n        }\\n        const runRejectedQuene = (err) => {\\n          let callback\\n          while(callback = this._rejectedQuene.shift()) {\\n            callback(err)\\n          }\\n        }\\n        if(val instanceof MyPromise) {\\n          val.then(res => {\\n            this._value = res\\n            runFullfilledQuene(res)\\n          }, err => {\\n            runRejectedQuene(err)\\n          })\\n        } else {\\n          this._value = val\\n          runFullfilledQuene(val)\\n        }\\n      })\\n    }\\n    _reject(err) {\\n      setTimeout(function() {\\n        if(this._status !== 'pending') return\\n        this._status = 'rejected'\\n        this._value = err\\n        let callback\\n        while(callback = this._rejectedQuene.shift()) {\\n          callback(err)\\n        }\\n      })\\n    }\\n    then(fullFilledFun, rejectedFun) {\\n      return new MyPromise((resolve, reject) => {\\n        // 封装一个promise回调成功的处理\\n        const handleFullFilledFun = val => {\\n          if(typeof fullFilledFun !== 'function') {\\n            reject(val)\\n          } else {\\n            const value = fullFilledFun(val)\\n            if(value instanceof MyPromise) {\\n              value.then(res => {\\n                resolve(res)\\n              }, err => {\\n                reject(err)\\n              })\\n            }\\n          }\\n        }\\n        // 封装一个promise回调失败的处理\\n        const handleRejectedFun = err => {\\n          if(typeof rejectedFun !== 'function') {\\n            reject(err)\\n          } else {\\n            const value = rejectedFun(err)\\n            if(value instanceof MyPromise) {\\n              value.then(res => {\\n                resolve(res)\\n              }, err => {\\n                reject(err)\\n              })\\n            }\\n          }\\n        }\\n        switch(this._status) {\\n          case 'pending':\\n            this._fullFilledQuene.push(handleFullFilledFun)\\n            this._rejectedQuene.push(handleRejectedFun)\\n            break\\n          case 'fullfilled':\\n            handleFullFilledFun(this._value)\\n            break\\n          case 'rejected':\\n            handleRejectedFun(this._value)\\n            break\\n        }\\n      })\\n    }\\n    catch(errFun) {\\n      return this.then(undefined, errFun)\\n    }\\n    finally(callback) {\\n      return this.then(\\n        value => MyPromise.resolve(callback()).then(() => value),\\n        err => MyPromise.resolve(callback()).then(() => err)\\n      )\\n    }\\n    static resolve(val) {\\n      if(val instanceof MyPromise) return val\\n      return new MyPromise(resolve => resolve(val))\\n    }\\n    static reject(err) {\\n      return new MyPromise((resovle, reject) => reject(err))\\n    }\\n    static all(list) {\\n      return new MyPromise(resolve => {\\n        let arrPromise = []\\n        for(let [index, promiseItem] of list) {\\n          promiseItem.then(res => {\\n            arrPromise.push(res)\\n            if(arrPromise.length === list.length) resolve(arrPromise)\\n          })\\n        }\\n      })\\n    }\\n    static race(list) {\\n      return new MyPromise(resolve => {\\n        for(let [index, promiseItem] of list) {\\n          promiseItem.then(res => {\\n            resolve(res)\\n          })\\n        }\\n      })\\n    }\\n  }\\n  \")])])]),e._v(\" \"),t(\"h2\",{attrs:{id:\"防抖-节流实现\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#防抖-节流实现\"}},[e._v(\"#\")]),e._v(\" 防抖/节流实现\")]),e._v(\" \"),t(\"p\",[e._v(\"防抖的原理是，\"),t(\"strong\",[e._v(\"通过闭包缓存定时器，当缓存的定时器不为空时，则使用clearTimeout进行清除，然后再重新赋值为一个setTimeout，频繁操作中直到最后一步操作才会真正起效，前面的操作都会被清除掉\")]),e._v(\"。\")]),e._v(\" \"),t(\"details\",[t(\"summary\",[e._v(\"答案\")]),e._v(\" \"),t(\"pre\",[t(\"code\",[e._v(\"\\n  // 防抖（频繁操作最终只会执行一次）\\n  function debounce(fn, time) {\\n    let timeout = undefined\\n    return function() {\\n      let context = this\\n      let args = arguments\\n      if(timeout) clearTimeout(timeout)\\n      timeout = setTimeout(() => {\\n        fn.apply(context, args)\\n      }, time)\\n    }\\n  }\\n  \")])])]),e._v(\" \"),t(\"p\",[e._v(\"节流的原理是，\"),t(\"strong\",[e._v(\"通过闭包缓存当前时间，当下一步重复操作的时间减去缓存时间大于参数时间时，那么就会直接执行函数，控制在规定的时间内执行函数\")]),e._v(\"。\")]),e._v(\" \"),t(\"details\",[t(\"summary\",[e._v(\"答案\")]),e._v(\" \"),t(\"pre\",[t(\"code\",[e._v(\"\\n  // 节流（频繁操作只会每隔一段时间操作一次）\\n  function throttle(fn, time) {\\n    let tempTime = Date.now()\\n    return function() {\\n      let currentTime = Date.now()\\n      if(currentTime - tempTime > time) {\\n        fn.apply(this, arguments)\\n        tempTime = currentTime\\n      }\\n    }\\n  }\\n  \")])])]),e._v(\" \"),t(\"h2\",{attrs:{id:\"函数柯里化实现\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#函数柯里化实现\"}},[e._v(\"#\")]),e._v(\" 函数柯里化实现\")]),e._v(\" \"),t(\"p\",[e._v(\"函数柯里化的原理，就是\"),t(\"strong\",[e._v(\"将多个参数的单一函数转化为单一参数的多个函数\")]),e._v(\"。\")]),e._v(\" \"),t(\"p\",[e._v(\"在实现函数柯里化中，\"),t(\"strong\",[e._v(\"通过使用递归形式\")]),e._v(\"来将多个单一参数转换为多个参数为止。\")]),e._v(\" \"),t(\"p\",[e._v(\"如：sum(a, b, c, d) 相当于 sum(a)(b)(c)(d)，也相当于 sum(a, b)(c)(d)\")]),e._v(\" \"),t(\"details\",[t(\"summary\",[e._v(\"答案\")]),e._v(\" \"),t(\"pre\",[t(\"code\",[e._v(\"\\n  // 函数柯里化\\n  function curry(fn) {\\n    const judge = (...args) => \\n      args.length >= fn.length\\n        ? fn(...args)\\n        : (...arg) => judge(...args, ...arg)\\n    return judge\\n  }\\n  \")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);","extractedComments":[]}