<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面向对象编程思想 | Learing And Sharing</title>
    <meta name="description" content="好好学习，天天向上💪">
    <meta name="generator" content="VuePress 1.3.0">
    
    
    <link rel="preload" href="/keep-Learning/assets/css/0.styles.69d11f16.css" as="style"><link rel="preload" href="/keep-Learning/assets/js/app.90ccec97.js" as="script"><link rel="preload" href="/keep-Learning/assets/js/2.71580b53.js" as="script"><link rel="preload" href="/keep-Learning/assets/js/65.826334d1.js" as="script"><link rel="prefetch" href="/keep-Learning/assets/js/10.99f30dcf.js"><link rel="prefetch" href="/keep-Learning/assets/js/100.53100d9a.js"><link rel="prefetch" href="/keep-Learning/assets/js/101.02f72051.js"><link rel="prefetch" href="/keep-Learning/assets/js/102.60bb996e.js"><link rel="prefetch" href="/keep-Learning/assets/js/103.c7f3df5b.js"><link rel="prefetch" href="/keep-Learning/assets/js/104.e8378220.js"><link rel="prefetch" href="/keep-Learning/assets/js/105.90235e89.js"><link rel="prefetch" href="/keep-Learning/assets/js/106.f4905ea3.js"><link rel="prefetch" href="/keep-Learning/assets/js/107.02dfbd1b.js"><link rel="prefetch" href="/keep-Learning/assets/js/108.e4ffed8c.js"><link rel="prefetch" href="/keep-Learning/assets/js/109.2f6191db.js"><link rel="prefetch" href="/keep-Learning/assets/js/11.ccfc084d.js"><link rel="prefetch" href="/keep-Learning/assets/js/110.05776fb6.js"><link rel="prefetch" href="/keep-Learning/assets/js/111.b05f070d.js"><link rel="prefetch" href="/keep-Learning/assets/js/112.e07a4e74.js"><link rel="prefetch" href="/keep-Learning/assets/js/113.71af1d2b.js"><link rel="prefetch" href="/keep-Learning/assets/js/114.914195f4.js"><link rel="prefetch" href="/keep-Learning/assets/js/115.3a0e92aa.js"><link rel="prefetch" href="/keep-Learning/assets/js/116.4ab80baa.js"><link rel="prefetch" href="/keep-Learning/assets/js/12.5bee8056.js"><link rel="prefetch" href="/keep-Learning/assets/js/13.05de0df0.js"><link rel="prefetch" href="/keep-Learning/assets/js/14.d86b4a20.js"><link rel="prefetch" href="/keep-Learning/assets/js/15.887efa99.js"><link rel="prefetch" href="/keep-Learning/assets/js/16.f7c7fa8d.js"><link rel="prefetch" href="/keep-Learning/assets/js/17.dbf7a65f.js"><link rel="prefetch" href="/keep-Learning/assets/js/18.e57690bf.js"><link rel="prefetch" href="/keep-Learning/assets/js/19.7486ada7.js"><link rel="prefetch" href="/keep-Learning/assets/js/20.d9250e4c.js"><link rel="prefetch" href="/keep-Learning/assets/js/21.71046546.js"><link rel="prefetch" href="/keep-Learning/assets/js/22.5d1bafeb.js"><link rel="prefetch" href="/keep-Learning/assets/js/23.06f0e746.js"><link rel="prefetch" href="/keep-Learning/assets/js/24.2d27300f.js"><link rel="prefetch" href="/keep-Learning/assets/js/25.08ee3872.js"><link rel="prefetch" href="/keep-Learning/assets/js/26.b747bff1.js"><link rel="prefetch" href="/keep-Learning/assets/js/27.895e5c28.js"><link rel="prefetch" href="/keep-Learning/assets/js/28.8674bd28.js"><link rel="prefetch" href="/keep-Learning/assets/js/29.00b3c0e2.js"><link rel="prefetch" href="/keep-Learning/assets/js/3.227fd7b0.js"><link rel="prefetch" href="/keep-Learning/assets/js/30.7c8a2e90.js"><link rel="prefetch" href="/keep-Learning/assets/js/31.4e94fa86.js"><link rel="prefetch" href="/keep-Learning/assets/js/32.24db43de.js"><link rel="prefetch" href="/keep-Learning/assets/js/33.3a9d7c5b.js"><link rel="prefetch" href="/keep-Learning/assets/js/34.455ff1fa.js"><link rel="prefetch" href="/keep-Learning/assets/js/35.bf04ef16.js"><link rel="prefetch" href="/keep-Learning/assets/js/36.f733bfb6.js"><link rel="prefetch" href="/keep-Learning/assets/js/37.507ec8ee.js"><link rel="prefetch" href="/keep-Learning/assets/js/38.4c8024fc.js"><link rel="prefetch" href="/keep-Learning/assets/js/39.e5094649.js"><link rel="prefetch" href="/keep-Learning/assets/js/4.c62e84b3.js"><link rel="prefetch" href="/keep-Learning/assets/js/40.6dd7a473.js"><link rel="prefetch" href="/keep-Learning/assets/js/41.14db9a5d.js"><link rel="prefetch" href="/keep-Learning/assets/js/42.342c49d2.js"><link rel="prefetch" href="/keep-Learning/assets/js/43.e2f02df0.js"><link rel="prefetch" href="/keep-Learning/assets/js/44.85c43572.js"><link rel="prefetch" href="/keep-Learning/assets/js/45.2d71b584.js"><link rel="prefetch" href="/keep-Learning/assets/js/46.26841be2.js"><link rel="prefetch" href="/keep-Learning/assets/js/47.2be49ff6.js"><link rel="prefetch" href="/keep-Learning/assets/js/48.b0982983.js"><link rel="prefetch" href="/keep-Learning/assets/js/49.0160ec63.js"><link rel="prefetch" href="/keep-Learning/assets/js/5.c9cb8de9.js"><link rel="prefetch" href="/keep-Learning/assets/js/50.d1a3af12.js"><link rel="prefetch" href="/keep-Learning/assets/js/51.a655886f.js"><link rel="prefetch" href="/keep-Learning/assets/js/52.93851e74.js"><link rel="prefetch" href="/keep-Learning/assets/js/53.c8009c28.js"><link rel="prefetch" href="/keep-Learning/assets/js/54.7945804f.js"><link rel="prefetch" href="/keep-Learning/assets/js/55.0d1b82a0.js"><link rel="prefetch" href="/keep-Learning/assets/js/56.ea4f3968.js"><link rel="prefetch" href="/keep-Learning/assets/js/57.c7fe55e7.js"><link rel="prefetch" href="/keep-Learning/assets/js/58.e2e1b6dd.js"><link rel="prefetch" href="/keep-Learning/assets/js/59.195b09a3.js"><link rel="prefetch" href="/keep-Learning/assets/js/6.7294f365.js"><link rel="prefetch" href="/keep-Learning/assets/js/60.b0c6ca2b.js"><link rel="prefetch" href="/keep-Learning/assets/js/61.d8137606.js"><link rel="prefetch" href="/keep-Learning/assets/js/62.354a6c3b.js"><link rel="prefetch" href="/keep-Learning/assets/js/63.42a16259.js"><link rel="prefetch" href="/keep-Learning/assets/js/64.44130cd9.js"><link rel="prefetch" href="/keep-Learning/assets/js/66.39bd2327.js"><link rel="prefetch" href="/keep-Learning/assets/js/67.89147bbe.js"><link rel="prefetch" href="/keep-Learning/assets/js/68.a7602bd4.js"><link rel="prefetch" href="/keep-Learning/assets/js/69.028f1340.js"><link rel="prefetch" href="/keep-Learning/assets/js/7.a9fa44ec.js"><link rel="prefetch" href="/keep-Learning/assets/js/70.3bb91667.js"><link rel="prefetch" href="/keep-Learning/assets/js/71.65fb15dd.js"><link rel="prefetch" href="/keep-Learning/assets/js/72.00066c85.js"><link rel="prefetch" href="/keep-Learning/assets/js/73.47b522ff.js"><link rel="prefetch" href="/keep-Learning/assets/js/74.7a6ef089.js"><link rel="prefetch" href="/keep-Learning/assets/js/75.b187d3a1.js"><link rel="prefetch" href="/keep-Learning/assets/js/76.88a347ac.js"><link rel="prefetch" href="/keep-Learning/assets/js/77.6f86a34a.js"><link rel="prefetch" href="/keep-Learning/assets/js/78.d0ed26d6.js"><link rel="prefetch" href="/keep-Learning/assets/js/79.83c1ce53.js"><link rel="prefetch" href="/keep-Learning/assets/js/8.acbc06dd.js"><link rel="prefetch" href="/keep-Learning/assets/js/80.a48aa37a.js"><link rel="prefetch" href="/keep-Learning/assets/js/81.6eacd104.js"><link rel="prefetch" href="/keep-Learning/assets/js/82.25ef373b.js"><link rel="prefetch" href="/keep-Learning/assets/js/83.09550954.js"><link rel="prefetch" href="/keep-Learning/assets/js/84.e8671abc.js"><link rel="prefetch" href="/keep-Learning/assets/js/85.b1b7d209.js"><link rel="prefetch" href="/keep-Learning/assets/js/86.d297bac9.js"><link rel="prefetch" href="/keep-Learning/assets/js/87.eeea66b3.js"><link rel="prefetch" href="/keep-Learning/assets/js/88.0ea72a36.js"><link rel="prefetch" href="/keep-Learning/assets/js/89.4155e98e.js"><link rel="prefetch" href="/keep-Learning/assets/js/9.ad2f8d07.js"><link rel="prefetch" href="/keep-Learning/assets/js/90.611a7011.js"><link rel="prefetch" href="/keep-Learning/assets/js/91.e84d85cf.js"><link rel="prefetch" href="/keep-Learning/assets/js/92.30b75a79.js"><link rel="prefetch" href="/keep-Learning/assets/js/93.0ccb8db1.js"><link rel="prefetch" href="/keep-Learning/assets/js/94.f5e0fbaf.js"><link rel="prefetch" href="/keep-Learning/assets/js/95.7e23aad8.js"><link rel="prefetch" href="/keep-Learning/assets/js/96.654c8e0c.js"><link rel="prefetch" href="/keep-Learning/assets/js/97.b65e23fb.js"><link rel="prefetch" href="/keep-Learning/assets/js/98.e14a8d6c.js"><link rel="prefetch" href="/keep-Learning/assets/js/99.e2ce5525.js">
    <link rel="stylesheet" href="/keep-Learning/assets/css/0.styles.69d11f16.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/keep-Learning/" class="home-link router-link-active"><!----> <span class="site-name">Learing And Sharing</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/keep-Learning/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术分享" class="dropdown-title"><span class="title">技术分享</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/keep-Learning/javascript/javascript-learning-and-summary/" class="nav-link router-link-active">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/html/html-learning-and-summary/" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/css/css-learning-and-summary/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/react/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/webpack/webpack-learning-and-summary/" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/ts/ts-learning-and-summary/" class="nav-link">
  Typescript
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/nodejs/nodejs-learning-and-summary/" class="nav-link">
  Nodejs
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/weex/weex-learning-and-summary/" class="nav-link">
  Weex
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/network/network-learning-and-summary/" class="nav-link">
  Network
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/datastructure/datastructure-learning-and-summary/" class="nav-link">
  数据结构
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/mixin/mixin-learning-and-summary/" class="nav-link">
  日常杂记
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/Andraw-lin" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/keep-Learning/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术分享" class="dropdown-title"><span class="title">技术分享</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/keep-Learning/javascript/javascript-learning-and-summary/" class="nav-link router-link-active">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/html/html-learning-and-summary/" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/css/css-learning-and-summary/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/react/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/webpack/webpack-learning-and-summary/" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/ts/ts-learning-and-summary/" class="nav-link">
  Typescript
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/nodejs/nodejs-learning-and-summary/" class="nav-link">
  Nodejs
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/weex/weex-learning-and-summary/" class="nav-link">
  Weex
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/network/network-learning-and-summary/" class="nav-link">
  Network
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/datastructure/datastructure-learning-and-summary/" class="nav-link">
  数据结构
</a></li><li class="dropdown-item"><!----> <a href="/keep-Learning/mixin/mixin-learning-and-summary/" class="nav-link">
  日常杂记
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/Andraw-lin" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/keep-Learning/javascript/javascript-learning-and-summary" class="sidebar-heading clickable router-link-active open"><span>JavaScript 学习和总结</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/你搞懂正则了吗.html" class="sidebar-link">你搞懂正则了吗</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/如何优雅地改善程序中for循环.html" class="sidebar-link">如何优雅地改善程序中for循环</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/单点登录的思考.html" class="sidebar-link">单点登录(SSO)的思考</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/你对同构了解多少.html" class="sidebar-link">你对同构了解多少</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/Javascript 中浮点数的精度问题.html" class="sidebar-link">Javascript中浮点数的精度问题</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/ES6-Summary.html" class="sidebar-link">ES6 Summary</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/ES7-Summary.html" class="sidebar-link">ES7 Summary</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/ES8-Summary.html" class="sidebar-link">ES8 Summary</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/ES9-Summary.html" class="sidebar-link">ES9 Summary</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/ES10-Summary.html" class="sidebar-link">ES10 Summary</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/面向对象编程.html" class="active sidebar-link">面向对象编程思想</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/keep-Learning/javascript/javascript-learning-and-summary/面向对象编程.html#了解对象" class="sidebar-link">了解对象</a></li><li class="sidebar-sub-header"><a href="/keep-Learning/javascript/javascript-learning-and-summary/面向对象编程.html#对象属性" class="sidebar-link">对象属性</a></li><li class="sidebar-sub-header"><a href="/keep-Learning/javascript/javascript-learning-and-summary/面向对象编程.html#对象的创建" class="sidebar-link">对象的创建</a></li><li class="sidebar-sub-header"><a href="/keep-Learning/javascript/javascript-learning-and-summary/面向对象编程.html#对象的继承" class="sidebar-link">对象的继承</a></li></ul></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/微前端.html" class="sidebar-link">微前端</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/浅拷贝和深拷贝.html" class="sidebar-link">浅拷贝和深拷贝</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/谈谈Vue和React间的区别.html" class="sidebar-link">谈谈Vue和React间的区别</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/移动端适配方案.html" class="sidebar-link">移动端适配方案</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/手写实现那回事.html" class="sidebar-link">手写实现那回事</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/Talking-About-JS-Closures-And-This-Keywords.html" class="sidebar-link">闭包和this指向问题</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/AJAX-Cache-Principle.html" class="sidebar-link">Ajax缓存</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/Memoization-Cache-Mechanism.html" class="sidebar-link">Memoization缓存机制</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/Talk-About-Calls-Apply-And-Bind-In-JavaScript.html" class="sidebar-link">call、apply和bind</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/The-Concrete-Realization-Of-Jsonp.html" class="sidebar-link">JSONP实现</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/Variables-And-Functions-Hosting-In-Javascript.html" class="sidebar-link">变量提升和函数提升</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/On-The-New-Characteristics-Of-Promise.html" class="sidebar-link">Promise特性</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/Talking-About-The-Push-Technology-Of-WEB-Server.html" class="sidebar-link">服务器推送技术</a></li><li><a href="/keep-Learning/javascript/javascript-learning-and-summary/AJAX-Cache-Principle.html" class="sidebar-link">Ajax缓存</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="面向对象编程思想"><a href="#面向对象编程思想" class="header-anchor">#</a> 面向对象编程思想</h1> <p>日常开发中，面向对象编程思想对于 JavaScript 来说显得日益重要。下面就针对 ES5 在面向对象编程实现上进行一些总结，基于《JavaScript高级程序设计》。</p> <h2 id="了解对象"><a href="#了解对象" class="header-anchor">#</a> 了解对象</h2> <p>在<code>JavaScript</code>中，创建对象的方法一般只用两种方式，如下：</p> <ul><li>通过<code>Object</code>实例化创建；</li> <li>使用对象字面量方式；</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 第一种方式</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Andraw'</span>
obj<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name
<span class="token punctuation">}</span>

<span class="token comment">// 第二种方式</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'Andraw'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">getName</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="对象属性"><a href="#对象属性" class="header-anchor">#</a> 对象属性</h2> <p>对于对象属性，可以分为两类：</p> <ol><li>数据属性；</li> <li>访问器属性；</li></ol> <p>这两者有什么异同呢？为了理解上述的异同，首先先了解一下定义在属性内部的<strong>特性(attribute)</strong>，用于描述属性的各种特征</p> <ul><li><p><strong>[[ Configurabale ]]</strong></p> <p>表示能否通过<code>delete</code>删除属性、或能否修改属性的内部特性、或能否把属性修改为访问器属性等</p></li> <li><p><strong>[[ Enumerable ]]</strong></p> <p>表示该属性是否可遍历，即能否通过<code>for-in</code>或<code>Object.keys()</code>遍历返回属性</p></li> <li><p><strong>[[ Writable ]]</strong></p> <p>表示能否直接修改属性的值（用于数据属性）</p></li> <li><p><strong>[[ Value ]]</strong></p> <p>代表该属性的值（用于数据属性）</p></li> <li><p><strong>[[ Get ]]</strong></p> <p>在读取属性时调用的函数（用于访问器属性）</p></li> <li><p><strong>[[ Set ]]</strong></p> <p>在写入属性时调用的函数（用于访问器属性）</p></li></ul> <p>简单滴说，数据属性和访问器属性的区别就是赋值和设置值方式不同，数据属性使用<code>[[ value ]]</code>和<code>[[ Writable ]]</code>特性，访问器属性使用<code>[[ Get ]]</code>和<code>[[ Set ]]</code>特性。</p> <p>内部特性主要是用于为了实现<code>JavaScript引擎</code>用的，在<code>JavaScript</code>中是无法直接访问的。如果想对对象属性进行定义内部特性，就需要用到<code>ES5中Object.defineProperty()方法</code>，接受三个参数：属性所在的对象、属性名、描述符对象（描述符对象的属性必须包括内部特性），直接上栗子：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 数据属性</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  configurable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  writable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  value<span class="token punctuation">:</span> <span class="token string">'Andraw'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Tom'</span>
<span class="token keyword">delete</span> person<span class="token punctuation">.</span>name
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span>			<span class="token comment">// 'Andraw'</span>

<span class="token comment">// 访问器属性</span>
<span class="token keyword">var</span> book <span class="token operator">=</span> <span class="token punctuation">{</span>
  _year<span class="token punctuation">:</span> <span class="token number">2008</span>
<span class="token punctuation">}</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span> <span class="token string">'year'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_year
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">set</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token keyword">this</span><span class="token punctuation">.</span>_year <span class="token operator">=</span> val
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
book<span class="token punctuation">.</span>year <span class="token operator">=</span> <span class="token number">2018</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span>year<span class="token punctuation">)</span>			<span class="token comment">// 2018</span>

<span class="token comment">// 定义多个属性</span>
<span class="token keyword">var</span> book <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  _year<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    value<span class="token punctuation">:</span> <span class="token number">2018</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  year<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_year
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_year <span class="token operator">=</span> val
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>需要注意的是，<code>Object.defineProperty()</code>方法中若不指定特性值，configurable、enumerable、writable默认都是为false。而直接在对象定义的属性，configurable、enumerable、writable默认都是为true。</p> <p>另外，通过<code>Object.getOwnPropertyDescriptor()方法</code>可以获得给定属性的描述符，直接上栗子：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  configurable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  writable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  value<span class="token punctuation">:</span> <span class="token string">'Andraw'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> descriptor <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">.</span>writable<span class="token punctuation">)</span>			<span class="token comment">// false</span>
</code></pre></div><h2 id="对象的创建"><a href="#对象的创建" class="header-anchor">#</a> 对象的创建</h2> <p>由于上面说过，一般使用<code>Object对象</code>实例化和对象字面量的两种方式来快捷创建单个对象。但是，要想创建多个变量，这两种方式就会出现很多重复代码。为此，可通过下面的方式来封装创建对象的方式：</p> <p>一、Factory Mode（工厂模式）</p> <p>工厂模式实现的方式很简单，就是在函数中通过创建一个新的对象，然后再在这个对象上定义属性或方法。直接看栗子：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// Factory Mode</span>
<span class="token keyword">function</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  obj<span class="token punctuation">.</span>name <span class="token operator">=</span> name
  obj<span class="token punctuation">.</span>age <span class="token operator">=</span> age
  obj<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> obj
<span class="token punctuation">}</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">'Andraw'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>			<span class="token comment">// &quot;Andraw&quot;</span>
</code></pre></div><p>工厂模式优点就是可以量产多个对象，但缺点就是无法识别对象的问题（即无法知道一个对象的类型）。如何理解这句话？看栗子：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 接着上面的栗子，通过实例的constructor属性可判断对象类型</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span>			<span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>constructor <span class="token operator">===</span> createPerson<span class="token punctuation">)</span>			<span class="token comment">// false</span>
</code></pre></div><p>二、Constructor Mode（构造函数模式）</p> <p>构造函数模式就是解决了对象类型的识别问题，定义构造函数时为了区别普通函数，规范是首字母为大写。直接看栗子：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// Constructor Mode</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Andraw'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>getName<span class="token punctuation">)</span>			<span class="token comment">// &quot;Andraw&quot;</span>
</code></pre></div><p>使用构造函数模式创建对象，必须使用<code>new操作符</code>，使用这种方式创建对象实际会经历以下四个步骤：</p> <ul><li>创建一个新对象；</li> <li>将构造函数的作用域赋给新对象（即this就指向这个新对象）；</li> <li>执行构造函数中的代码（即定义属性或方法）；</li> <li>最后返回这个新对象；</li></ul> <p>为了检测对象类型，除了上面提到的<code>constructor属性</code>，还可以使用<code>instanceof操作符</code>，而且官方提到使用<code>instanceof</code>更可靠一些哈哈😄</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// constructor（可以单一地用来标记某个对象类型，即由哪个构造函数new出来）</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span>			<span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Perosn<span class="token punctuation">)</span>			<span class="token comment">// true</span>

<span class="token comment">// instanceof</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span>			<span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span>			<span class="token comment">// true</span>
</code></pre></div><p>为什么当把对象类型与<code>Object</code>比较使用<code>instanceof</code>时总会返回true？别忘了，所有对象的顶层都是<code>Object</code>（即所有对象都是Object的实例），简单滴说，就是所有对象都是通过<code>Object</code>继承而来。当然，对于构造函数，有一些疑问也会随之而来：</p> <ol><li><p>是否可以将构造函数当作普通函数？</p> <p>总所周知，当构造函数不通过<code>new操作符</code>来创建对象时，实际上就是一个普通函数的调用，然而，<code>this</code>指向也会改变：</p> <ul><li>普通函数创建：<code>this</code>指向<code>window对象</code>；</li> <li>构造函数创建：<code>this</code>指向<code>所创建的新对象</code>；</li> <li>使用<code>call</code>或<code>apply</code>调用：<code>this</code>指向该方法的第一个参数传入的对象（实际在这个传入对象的作用域调用相对应的方法）</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 构造函数当普通函数调用</span>
<span class="token function">Person</span><span class="token punctuation">(</span><span class="token string">'Andarw'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
<span class="token comment">// 由于this指向的是window对象，因此所定义的属性和方法实际上就是全局属性或全局方法</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>			<span class="token comment">// &quot;Andraw&quot;</span>

<span class="token comment">// 使用call或apply调用（相当于在一个新对象的作用域中调用）</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'Andraw'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>			<span class="token comment">// &quot;Andraw&quot;</span>
</code></pre></div></li> <li><p>构造函数的缺陷</p> <p>构造函数虽然好用，但是在一些多个对象共用方法定义时，就不可避免地创建多个共用方法，而我们的目的就是想对于共用的方法只需定义一次即可，可优化内存，看栗子即可明白：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Perosn</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
  <span class="token keyword">this</span><span class="token punctuation">.</span>getName <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">'return this.name'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Andraw'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>			<span class="token comment">// &quot;Andraw&quot;</span>
</code></pre></div><p>可以看到，每次<code>new</code>实例化创建对象后，都会无可避免地<code>new Funtion</code>来创建<code>getName</code>方法，这对于创建自定义该对象单独使用的方法是没问题，但是对于共用的方法就会浪费内存。当然也有方法可以解决，就是把方法通过外部定义：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Perosn</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
  <span class="token keyword">this</span><span class="token punctuation">.</span>getName <span class="token operator">=</span> getName
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name
<span class="token punctuation">}</span>
</code></pre></div><p>这种写法虽然可以解决构造函数的共用方法的定义问题（即<code>Person</code>的所有实例都会共享全局作用域下定义的同一个<code>getNmae</code>函数）。</p> <p>同样地，上述也会导致一个新的问题，就是全局作用域下的定义的函数只能被某个对象调用无法体现全局的广域含义。当对象需定义多个方法时也不可避免地会在定义多个全局方法，同时容易导致全局污染，也就不能体现对象的封装性。</p></li></ol> <p>三、Prototype Mode（原型模式）</p> <p>默认情况下，每个函数都会有一个<code>Prototype</code>属性（是一个指针），指向<strong>一个由特定类型（构造函数）下所有实例共享的属性和方法的对象</strong>。简单滴说，就是<code>new</code>出的实例的原型对象。</p> <p>原型对象的好处，可以让所有实例共享它的属性和方法（封装性）。因此，原型模式也就解决了构造函数模式的缺陷，直接上栗子🌰：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Andraw'</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token punctuation">}</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>getName <span class="token operator">===</span> person2<span class="token punctuation">.</span>getName<span class="token punctuation">)</span>		<span class="token comment">// true</span>
</code></pre></div><ol><li><p>理解原型对象</p> <ul><li><p>当创建一个新函数，js就会根据一组特定的规则为该函数创建一个<code>Prototype</code>属性，指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个<code>constructor(构造函数)</code>属性，指向原函数。看栗子🌰：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span>		<span class="token comment">// true</span>
</code></pre></div></li> <li><p>另外，所有对象实例也包含一个内部指针（ES5上叫<code>[[Prototype]]</code>），指向构造函数的原型对象。在FireFox、Safari和Chrome上是支持通过访问实例的<code>__Proto__</code>属性，来访问到原型对象。</p> <ul><li><p>通过<code>isPrototypeOf()</code>方法可确定对象是否为实例的原型对象。</p></li> <li><p>通过<code>Object.getPrototypeOf()</code>方法可返回<code>[[Prototype]]</code>的值。</p></li> <li><p>通过<code>hasOwnProperty()</code>方法，可确定该实例是否存在该属性，若存在原型对象上就会返回false</p> <p>看栗子🌰：</p></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// isPrototype()</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>Person1<span class="token punctuation">)</span><span class="token punctuation">)</span>		<span class="token comment">// true</span>

<span class="token comment">// getPrototypeOf()</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>		<span class="token comment">// true</span>

<span class="token comment">// hasOwnProperty()</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>		<span class="token comment">// false</span>
</code></pre></div><p><img src="http://learning-every-day.oss-cn-shenzhen.aliyuncs.com/javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/Prototype-Mode.png" alt=""></p></li> <li><p>当访问一个对象的属性时，会先看该对象下是否存在该属性，若不存在，就会根据原型链（即<code>[[Prototype]]</code>）访问原型对象是否存在该属性，若还是不存在时，就会返回<code>undefined</code>。所以访问一个对象属性，最多会进行搜索两次。</p> <p>需要注意的是，当对象上定义的属性覆盖了原型对象上的属性时（即重写），访问该对象属性就会直接屏蔽掉原型对象上同名属性的值，只有通过<code>delete</code>操作才可以复原。</p> <p>看栗子🌰：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Andraw'</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
person1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Tom'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>name<span class="token punctuation">)</span>		<span class="token comment">// 'Tom'</span>
<span class="token keyword">delete</span> person1<span class="token punctuation">.</span>name
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>name<span class="token punctuation">)</span>		<span class="token comment">// 'Andraw'</span>
</code></pre></div></li></ul></li> <li><p>原型与 in 操作符</p> <p><code>in</code>操作符的使用方式有两种：单独使用和在<code>for-in</code>循环中使用。单独使用时，当属性在对象中可访问时就返回<code>true</code>，<strong>无论属性是在对象中还是在其原型对象上</strong>。</p> <p>看栗子🌰：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Andraw'</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'name'</span> <span class="token keyword">in</span> Person1<span class="token punctuation">)</span>		<span class="token comment">// true</span>
Person1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Tom'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'name'</span> <span class="token keyword">in</span> Person1<span class="token punctuation">)</span>		<span class="token comment">// true</span>
</code></pre></div><p>另外，单独使用<code>in</code>操作符与<code>hasOwnProperty()</code>方法结合时，可以直接判断该属性是否在原型对象上：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">hasPrototypeProperty</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>name <span class="token keyword">in</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对象遍历返回<code>Key</code>方式有：</p> <ul><li><p>For-in循环</p> <p>遍历对象时，返回的是对象所有可访问、可枚举属性，注意的是，<strong>遍历时会沿着原型链向上遍历</strong>。看栗子🌰：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Andraw'</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
person1<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">12</span>
<span class="token comment">// for-in循环</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> person1<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">}</span>		
<span class="token comment">// 'age'</span>
<span class="token comment">// 'name'</span>
</code></pre></div></li> <li><p><code>Object.keys()</code>方法（IE9+）</p> <p>只返回该对象能访问的<strong>可枚举</strong>属性，不包括原型对象。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">)</span>		<span class="token comment">// age</span>
</code></pre></div></li> <li><p><code>Object.getOwnPropertyNames()</code>方法（IE9+）</p> <p>返回该对象访问的<strong>可枚举和不可枚举</strong>属性。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// constructor</span>
<span class="token comment">// name</span>
</code></pre></div></li></ul></li> <li><p>原型对象的语法糖</p> <p>由于上述每次赋值到原型对象时，都会重复编写<code>Person.prototype</code>，很显然是很麻烦的。为此，可以直接给原型对象直接赋值一个对象，如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'Andraw'</span>
<span class="token punctuation">}</span>
</code></pre></div><p>看似简单了，却包含着很多问题，最重要的就<strong>是<code>constructor</code>指向改变了，不再指向<code>Person</code>，而是指向了<code>Object</code>，相当于将原型对象直接<code>new Object()</code></strong>。</p> <p>另外，<strong>对象是不会存在<code>constructor</code>属性的，都是直接访问其原型对象的</strong>。</p> <p><code>instanceof</code>操作符，简单滴说其实就是对象的原型是否存在于左边实例的原型链上。</p> <p>看栗子🌰：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">,</span> person<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>		<span class="token comment">// true, true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">,</span> person<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span>		<span class="token comment">// true, true</span>
</code></pre></div><p>当然，可以直接赋值对象字面量时，可强制赋值<code>constructor</code>指向回<code>Person</code>，但这样就会导致重写<code>constructor</code>属性的<code>[[Enumerable]]</code>可枚举属性为true，因为默认情况下它是为false的。为此，可直接使用<code>Object.defineProperty()</code>方法来解决：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">'constructor'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  enumerable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  value<span class="token punctuation">:</span> Person
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>原型的动态性</p> <p>当在创建实例后，才去重写原型对象（即使用原型对象的语法糖），无疑会切断原型对象与实例间的关系，但需要注意的是原来的原型对象依旧存在的。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
person<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  constructor<span class="token punctuation">:</span> Person<span class="token punctuation">,</span>
  name<span class="token punctuation">:</span> <span class="token string">'Andraw'</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span>		<span class="token comment">// undefined</span>
</code></pre></div><p>在创建实例时，才会默认指定实例的<code>[[Prototype]]</code>属性。</p></li> <li><p>原型模式问题</p> <p>原型模式最大的问题就是引用类型的共享问题。当一个实例改变了原型对象的引用类型属性时，也会导致其他实例访问这个属性时改变（因为引用类型指向同一个指针）。</p> <p>看栗子🌰：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  constructor<span class="token punctuation">:</span> Person<span class="token punctuation">,</span>
  name<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Andraw'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> Person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
person1<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'Tom'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>name<span class="token punctuation">)</span>		<span class="token comment">// ['Andraw', 'Tom']</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>name<span class="token punctuation">)</span>		<span class="token comment">// ['Andraw', 'Tom']</span>
</code></pre></div></li></ol> <p>四、Constructor Mode And Prototype Mode（组合使用构造函数模式和原型模式）</p> <p>创建对象最好的方式，就是组合使用构造函数模式和原型模式。构造函数模式用于定义实例独自需要属性或方法，而原型模式则是定义所用实例所共享的属性或方法。</p> <p>看栗子🌰：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>friends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  constructor<span class="token punctuation">:</span> Person<span class="token punctuation">,</span>
  <span class="token function-variable function">sayName</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Andraw'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Tom'</span><span class="token punctuation">)</span>
person1<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'haha'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>friends<span class="token punctuation">)</span>		<span class="token comment">// ['haha']</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>friends<span class="token punctuation">)</span>		<span class="token comment">// []</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>sayName <span class="token operator">===</span> person2<span class="token punctuation">.</span>sayName<span class="token punctuation">)</span>		<span class="token comment">// true</span>
</code></pre></div><p>五、Dynamic Prototype Mode（动态原型模式）</p> <p>动态原型模式，是一种封装构造函数和原型的方案。只需判断某个原型不存在时再去初始化原型，体现其封装性，直接看栗子🌰：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token comment">// 判断原型中的getName方法是否存在，存在时就不再初始化</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>getName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name
    <span class="token punctuation">}</span>
    <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">setName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>好明显，<code>if</code>判断中的代码只会执行一次，因为当原型不存在某个属性或方法时，就进行了初始化，后续不再需要初始化了。需注意的是，在初始化过程中，不能直接给原型对象赋值为一个对象，这样就会切断实例与原型间的关系。</p> <h2 id="对象的继承"><a href="#对象的继承" class="header-anchor">#</a> 对象的继承</h2> <p>继承可以分为两种：接口继承（只继承方法签名）和实现继承（继承实际的方法）。目前<code>ECMAScirpt5</code>由于函数没有签名，只支持实现继承。<code>javascript</code>的实现继承依靠的是<strong>原型链</strong>。</p> <p>一、原型链</p> <p>在上面讨论的原型模式中，原型链其实可以很容易看到。当一个类型的实例创建时，原型链也就开始创建，实例的内部指针<code>[[Prototype]]</code>指向原型对象，而原型对象的内部指针<code>[[Prototype]]</code>则指向Object的原型（即对象的顶部）。</p> <p>那原型链是如何在实现继承中其作用的？很简单，就是<strong>将一个类型的原型直接赋值为另外一个类型的实例即可</strong>。</p> <p>看栗子🌰：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Parent'</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// Child继承Parent</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name<span class="token punctuation">)</span>		<span class="token comment">// Parent</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span>		<span class="token comment">// Parent</span>
</code></pre></div><p>需注意的是，<code>Child</code>的默认原型对象其实依旧存在的，只是强制将<code>Child.prototype</code>重写了<code>Parent</code>的实例，进而<code>Child.prototype</code>中就存在了一个内部指针指向<code>Parent.prototype</code>。</p> <ol><li><p>确定原型和实例的关系</p> <p>确定原型和实例间的关系有两种，分别是：<code>instanceof</code>操作符和<code>isPrototypeOf()</code>方法，直接拿上述的栗子：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// instanceof</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Child</span><span class="token punctuation">)</span>		<span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Parent</span><span class="token punctuation">)</span>		<span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span>		<span class="token comment">// true</span>

<span class="token comment">// isPrototypeOf()</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Child<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span>		<span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Parent<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span>		<span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span>		<span class="token comment">// true</span>
</code></pre></div></li> <li><p>谨慎定义方法</p> <p>当子类型重写或添加超类型的方法时，<strong>需在原型替换语句之后编写</strong>，不然重写或新增的方法会存在于原来的原型对象中，直接看栗子🌰：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Parent'</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">setName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 	<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
person1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">'person1'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>		<span class="token comment">// person1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>		<span class="token comment">// Parent</span>

</code></pre></div><p>需注意的是，在给<code>Child</code>原型初始化时，不能用对象字面量，这样会导致<code>Child</code>不再继承<code>Parent</code>，而是直接继承了<code>Object</code>对象。</p></li> <li><p>原型链的问题</p> <ul><li><p>引用类型共享问题</p> <p>当子类型中的某个方法对父类型中的某个引用类型属性改变时，会使所有实例引用的这个属性都会共同改变，直接看栗子🌰：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Parent'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">setName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
person1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">'person1'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>name<span class="token punctuation">)</span>		<span class="token comment">// ['Parent', 'person1']</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>name<span class="token punctuation">)</span>		<span class="token comment">// ['Parent', 'person1']</span>
</code></pre></div><p>当执行 <code>setName</code>方法时，由于在<code>person1</code>中无法找到<code>this.name</code>，而是在<code>Child.prototype</code>中找到，因此才去执行<code>push</code>方法。</p></li> <li><p>无法向超类型传递参数（<strong>超类型指的是父类构造函数！</strong>）</p> <p>上述栗子可以看到，当<code>person1和person2</code>想在<code>Parent</code>构造函数中传入参数时，上述栗子的确是无法做到这一点，为了解决这两个问题，可以使用借用构造函数继承方法来解决</p></li></ul></li></ol> <p>二、借用构造函数</p> <p>借用构造函数方法，是为了<strong>解决原型链中引用类型以及无法向超类型传递参数所带来的问题方案</strong>。简单滴说，就是通过使用<code>apply</code>和<code>call</code>方法在子类型作用域中直接执行父类型，进而传递参数。</p> <p>直接看栗子🌰：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token punctuation">[</span>name<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 在子类型中通过apply和call直接执行Parent构造函数</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">setName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'person1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'person2'</span><span class="token punctuation">)</span>
person1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">'person3'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>name<span class="token punctuation">)</span>		<span class="token comment">// ['person1', 'person3']</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>name<span class="token punctuation">)</span>		<span class="token comment">// ['person2']</span>
</code></pre></div><p>另外，需要注意的是，借用构造函数其实跟构造函数模式存在一样的问题，就是<strong>方法无法复用问题</strong>，即在<code>Child</code>或	<code>Parent</code>构造函数中定义的方法，每次<code>new</code>其实例时，都会重新创建该方法，就无法达到复用效果（如果是在<code>Child</code>的原型中定义方法，方法是共享的，但是就体现不了继承的含义）。</p> <p>三、组合继承（原型链和借用构造函数结合）</p> <p>组合继承，主体思想就是<strong>使用原型链在父级原型中实现实例的共享属性和方法，再使用借用构造函数来实现实例独有的属性或方法</strong>。</p> <p>看栗子🌰：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token punctuation">[</span>name<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token comment">// 父级共享方法统一放到父级原型中</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">setName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'person1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'person2'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>setName <span class="token operator">===</span> person2<span class="token punctuation">.</span>setName<span class="token punctuation">)</span>		<span class="token comment">// true</span>
</code></pre></div><p>组合继承可以有效滴解决了原型链继承的引用类型问题以及借用构造函数中方法无法复用的问题，也是常用的一种继承方式。</p> <p>四、原型继承</p> <p>原型继承的思想很简单，借助原型可基于已有的对象来进行继承，而不必再创建自定义的类型。代码思想如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过传入一个已有的对象，创建一个临时性的构造函数，再将原型直接赋值为传入对象完成一个继承，最后再返回这个新的对象实例。（即实现了一个传入对象的浅复制）</p> <p>看实践栗子🌰：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> parent <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'parent'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">,</span>
    child2 <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span>
child1<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'child1'</span><span class="token punctuation">)</span>
child2<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'child2'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>name<span class="token punctuation">)</span>		<span class="token comment">// ['parent', 'child1', 'child2']</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">.</span>name<span class="token punctuation">)</span>		<span class="token comment">// ['parent', 'child1', 'child2']</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>		<span class="token comment">// {}</span>
</code></pre></div><p>可以看到，继承后并创建的新对象其实是一个空对象，当访问<code>name</code>属性时候，就是访问了传入对象中的值，因此也就共享了传入对象的属性和方法。</p> <p><code>ES5</code>中为了简化，直接对原型继承封装了语法糖，即<code>Object.create()</code>方法，作用跟上面的<code>object</code>方法是一样的，同时也可以直接创建自定义属性避免共享引用类型的问题：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> parent <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'parent'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      name<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        value<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'child1'</span><span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    child2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span>
child2<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'child2'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>name<span class="token punctuation">)</span>		<span class="token comment">// ['child1']</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">.</span>name<span class="token punctuation">)</span>		<span class="token comment">// ['parent', 'child2']</span>
</code></pre></div><p>需要注意的是，<code>Object.create()</code>方法中的第二个参数，其实跟<code>Object.defineProperties()</code>方法的第二个参数一样的。</p> <p>五、寄生式继承</p> <p>寄生式继承可以说是原型继承的一个小拓展，简单滴说，就是<strong>在原型继承基础上，定义自定义的方法</strong>。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 寄生式继承方法</span>
<span class="token keyword">function</span> <span class="token function">inheritObj</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> clone <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
  clone<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> clone
<span class="token punctuation">}</span>
<span class="token keyword">var</span> parent <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'parent'</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token function">inheritObj</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>		<span class="token comment">// 'parent'</span>
</code></pre></div><p>可以看到，<strong>寄生式继承和原型继承考虑的目标都是已创建好对象</strong>，而不是考虑自定义类型和构造函数。</p> <p>寄生式继承存在问题跟构造函数一致，就是每次调用<code>inheritObj</code>方法时，都需要重新创建<code>sayName</code>方法，即<strong>方法无法复用</strong>的问题。</p> <p>六、寄生式组合继承</p> <p>虽说组合继承是普遍都能接受和使用的继承方式，但组合继承也存在问题，即需要调用两次父类型构造函数，第一次会初始化属性，第二次调用时就会重写该属性，看代码：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
Parent<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>		<span class="token comment">// 第二次调用（重写初始化属性）</span>
<span class="token punctuation">}</span>
child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>		<span class="token comment">// 第一次调用（初始化属性，其实这一步没必要）</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
<span class="token comment">// Parent {name: undefined}</span>
<span class="token comment">// {constructor: ƒ}</span>
</code></pre></div><p>上述代码，可以看到第一次调用父类型构造函数是没必要，它的主要作用就是为了能够让<code>child</code>原型和<code>parent</code>原型建立关系，而初始化属性就是完全没必要了，因为调用子类型构造函数创建实例时就会进行初始化属性。</p> <p>为此，寄生式组合继承可解决这个问题，即只需构建子类型原型和父类型原型之间关系即可，而初始化仅仅交给借用构造函数即可。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 寄生式组合继承构建子类型原型和父类型原型之间关系</span>
<span class="token keyword">function</span> <span class="token function">inheritObj</span><span class="token punctuation">(</span><span class="token parameter">child<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> clone <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
  clone<span class="token punctuation">.</span>constructor <span class="token operator">=</span> child
  child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> clone
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">inheritObj</span><span class="token punctuation">(</span>Child<span class="token punctuation">,</span> Parent<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
<span class="token comment">// Parent {constructor: ƒ}</span>
<span class="token comment">// {sayName: ƒ, constructor: ƒ}</span>
</code></pre></div><p>对比组合继承，可以看到，初始化属性这一步并不再执行，并且也不会再通过<code>new Parent()</code>方法来构建父类型和子类型原型之间关系，而是直接使用原型继承来构建父类型的原型和子类型的原型之间关系。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/keep-Learning/javascript/javascript-learning-and-summary/ES10-Summary.html" class="prev">
        ES10 Summary
      </a></span> <span class="next"><a href="/keep-Learning/javascript/javascript-learning-and-summary/微前端.html">
        微前端
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/keep-Learning/assets/js/app.90ccec97.js" defer></script><script src="/keep-Learning/assets/js/2.71580b53.js" defer></script><script src="/keep-Learning/assets/js/65.826334d1.js" defer></script>
  </body>
</html>
